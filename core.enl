// SYSTEM //

(defmacro defn [n b & fs] ^(def ~n (fn ~b ~@fs)))

(defn swap! [a f & xs] (reset! a (apply f (cons @a xs))))

(defn boolean [a] (if a true false))
(defn number [a] ($call $Number 'parseFloat a))

(defn nil? [a] (if ($exact a false) false ($eq a nil)))
(defn string? [a] (and a ($exact $String ('constructor a))))
(defn number? [a] (and a ($exact $Number ('constructor a))))
(defn boolean? [a] (and (not (nil? a)) ($exact $Boolean ('constructor a))))
(defn true? [a] ($exact a true))
(defn false? [a] ($exact a false))
(defn map? [a] (and a ($exact $Object ('constructor a))))
(defn map? [a] (and a ($exact $Set ('constructor a))))
(defn function? [a] (and a ($exact $Function ('constructor a))))
(defn regex? [a] (and a ($exact $RegExp ('constructor a))))

(def gensym
  (let [cnt (atom 0)]
    (fn [a]
      (swap! cnt inc)
      (str (if a a "G__") @cnt))))

(defn == [a b]
  ($exact ($val a) ($val b)))

(defn = [a b]
  (cond
    (string? a) (if (string? b)
                    (== a b))
    (nil? a)    (nil? b)
    (seq? a)    (and
                  (seq? b)
                  ($exact (count a) (count b))
                  (every? (fn [x] (= (nth x a) (nth x b))) (range 0 (count a))))
    (map? a)    (and
                  (= (sort (keys a)) (sort (keys b)))
                  (every? (fn [x] (= (get a x) (get b x))) (keys a)))
    true        ($exact a b)))



// SEQUENCES //

// Higher Order Functions
(defn map [f coll] ($call coll 'map (fn [x] (f x))))
(defn filter [p coll] ($call coll 'filter (fn [x] (p x))))
(defn remove [p coll] (filter (complement p) coll))
(defn reduce [f i coll] ($call coll 'reduce (fn [a v] (f a v)) i))
(defn reduce-right [f i coll] ($call coll 'reduceRight (fn [a v] (f a v)) i))
(defn every? [p coll] ($call coll 'every (fn [x] (p x))))
(defn some? [p coll] ($call coll 'some (fn [x] (p x))))

// Elements
(defn count [c]
  (if (seq? c)
    ($get c 'length)
    (count (keys c))))

(defn nth [n coll] ($get coll n))
(defn first [coll] (nth 0 coll))
(defn ffirst [coll] (first (first coll)))
(defn second [coll] (nth 1 coll))
(defn last [coll] (nth (dec (count coll)) coll))
(defn butlast [coll] ($call coll 'slice 0 (dec (count coll))))
(defn take [n coll] ($call coll 'slice 0 n))
(defn drop [n coll] ($call coll 'slice n))
(defn rest [coll] ($call coll 'slice 1))
(defn find [p coll] ($call coll 'find (fn [x] (p x))))
(defn split-at [n coll] (list (take n coll) (drop n coll)))

// Other
(defn empty? [coll] ($exact 0 (count coll)))
(defn reverse [coll] ($call ($call coll 'slice) 'reverse))

(defn comparator [op]
  (fn [a b]
    (let [left (op a b)]
      (cond
        (number? left) left
        (boolean? left) (cond left -1 (op b a) 1 true 0)
        true (throw "bad compare function")))))
        
(defn sort [& as]
  (condp = (count as)
    1 ($call ($call (first as) 'slice) 'sort)
    2 ($call ($call (second as) 'slice) 'sort (comparator (first as)))
    (throw "bad arity")))

(defn partition [n coll]
  (loop [acc ()
         coll coll]
    (if (empty? coll)
        acc
        (do
          (push! acc ($call coll 'slice 0 n))
          (recur acc (drop n coll))))))

(defn juxt [& fs]
  (fn [& xs] (map (fn [f] (apply f xs)) fs)))



// MATH //

//(defn + [& ns] (reduce $add 0 ns))
//(defn - [n & ns] (if (empty? ns) ($sub 0 n) (reduce $sub n ns)))
//(defn * [& ns] (reduce $mul 1 ns))
//(defn / [n & ns] (if (empty? ns) ($div 1 n) (reduce $div n ns)))

(def max ($get $Math 'max))
(def min ($get $Math 'min))
(def ceil ($get $Math 'ceil))
(def floor ($get $Math 'floor))
(def round ($get $Math 'round))

(defn even? [n] (== 0 (mod n 2)))
(defn odd? [n] (== 1 (mod n 2)))
(defn pos? [n] (> n 0))
(defn neg? [n] (< n 0))
(defn zero? [n] (== 0 n))
(defn inc [n] (+ n 1))
(defn dec [n] (- n 1))

(defn str [& s] (if s ($call s 'join "") ""))

(def ->json ($get $JSON 'stringify))
(def <-json ($get $JSON 'parse))



// HASH-MAPS //

(defn keys [m] ($call $Object 'keys m))
(defn vals [m] ($call $Object 'values m))
(defn get [m k d] (or ($get m k) d))
(defn contains? [m k] ($in k m))
(defn merge [m n] ($call $Object 'assign {} m n))

(defn assoc [m & kvs]
  (loop [m ($call $Object 'assign {} m)
         kvs kvs]
    (if (not-empty kvs)
        (do 
          ($set m (first kvs) (second kvs))
          (recur m (drop 2 kvs)))
        m)))

(defn dissoc [m & ks]
  (loop [m ($call $Object 'assign {} m)
         ks ks]
    (if (not-empty ks)
        (do 
          ($delete m (first ks))
          (recur m (rest ks)))
        m)))

(defn select-keys [m ks]
  (->> (keys m)
       (remove (fn [x] ($call ks 'includes x)))
       (cons m)
       (apply dissoc)))

(defn update [m k f & xs]
  (assoc m k (apply f (cons (get m k) xs))))

(defn seq [c]
  (if (> (count c) 0)
    (cond
      (seq? c)    c
      (map? c)    (('entries $Object) c)
      (string? c) ($call c 'split ""))))

(defn conj [a & bs]
  (cond
    (nil? a) bs
    (seq? a) (concat a bs)
    (map? a) (loop [a (merge {} a)
                    n (first bs)
                    bs (rest bs)]
               (cond
                 (map? n) ($call $Object 'assign a n)
                 (seq? n) ($set a (first n) (second n)))
               (if (empty? bs) a (recur a (first bs) (rest bs))))))



// LOGIC //

(defn complement [p]
  (fn [& args] (not (apply p args))))

(def not= (complement =))

(def not-empty (complement empty?))

(defmacro or [& xs]
  (if (empty? xs)
    nil
    (if ($exact 1 (count xs))
      (first xs)
      (let [cvar (gensym)]
        ^(let [~cvar ~(first xs)]
           (if ~cvar ~cvar (or ~@(rest xs))))))))

(defmacro and [& xs]
  (if (empty? xs)
    nil
    (if ($exact 1 (count xs))
      (first xs)
      (let [cvar (gensym)]
        ^(let [~cvar ~(first xs)]
           (if ~cvar (and ~@(rest xs)) ~cvar))))))

(def > $gt)
(def < $lt)
(defn >= [a b] (or (> a b) (= a b)))
(defn <= [a b] (or (< a b) (= a b)))



// MACROS //

(defmacro if-let [b t f] ^(let ~b (if ~(first b) ~t ~f)))
(defmacro when [p & fs] ^(if ~p (do ~@fs)))
(defmacro when-not [p & fs] ^(if ~p nil (do ~@fs)))
(defmacro when-let [b & fs] ^(let ~b (if ~(first b) (do ~@fs))))

(defmacro cond [& ps]
  (if (empty? ps)
    nil
    ^(if ~(first ps)
       ~(second ps)
       (cond ~@(drop 2 ps)))))

(defmacro condp [p exp & ts]
  (let [gpred (gensym "pred__")
        gexpr (gensym "expr__")
        init (if (odd? (count ts)) (last ts) nil)
        ts (if init (butlast ts) ts)
        ts (partition 2 ts)]
    ^(let [~gpred ~p ~gexpr ~exp]
       ~(reduce-right
          (fn [a v]
            (conj ^(if (~gpred ~(v 0) ~gexpr) ~(v 1)) a))
          init
          ts))))

(defmacro -> [v & fs]
  (if (empty? fs)
    v
    (let [f (first fs)
          f (if (seq? f) f (list f))]
      ^(-> (~(first f) ~v ~@(rest f)) ~@(rest fs)))))

(defmacro ->> [v & fs]
  (if (empty? fs)
    v
    (let [f (first fs)
          f (if (seq? f) f (list f))]
      ^(->> (~@f ~v) ~@(rest fs)))))

(defmacro as-> [v n & fs]
  ^(let ~(reduce (fn [a f] (conj a n f)) [n v] fs) ~n))



// MISC

(defn identity [a] a)

(defn comp [& fs]
  (fn [& xs]
    (reduce-right (fn [r x] (x r)) xs fs)))

(defn partial [f & xs]
  (fn [& ys]
    (apply f (concat xs ys))))

(defn re-groups [reg s]
  (if (not ($get reg 'global))
      ($call reg 'exec s)
      (loop [acc ()]
        (if-let [m ($call reg 'exec s)]
          (do
            ($call acc 'push m)
            (recur acc))
          acc))))
  
(defn re-find [reg s]
  (if ($get reg 'global)
    (map first (re-groups reg s))
    (first (re-groups reg s))))



// Interop

(defn $scr [s & args]
  ($call (-> $args ($get s) ($get 'call)) 'apply nil args))

(defn $color [c s]
  (str "\x60" c s "\x60"))

(defn $uncolor [s]
  ($call s 'replace rg"\x60[0-9A-Za-z](?!:.?\x60)([^\x60\n]+)\x60" '$1))
  
(defn $rarity->number [s]
  (number (second s)))
